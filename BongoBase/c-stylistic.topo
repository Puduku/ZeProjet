// c-stylistic.topo
// (c) Puduku - 2025
// ================== DRAFT ==========================

// Using stylistic devices in C (and other programmming languages)

// In Programming/software development, we (very roughly) distinct the two following phases:
// - preliminary conception/design 
// - writing and compiling the code (including testing and debugging)
//
// During preliminary conception phase...
// A new design does not emerges from nothing. Rather, new programming concepts (modules,
// classes, processes and so on) are based on adaptation and extension (generalization or
// specification) of existing concepts (ideas, principles, theories) and artifacts
// (devices and natural phenomena).
// The major "engines" used by humans to derive new concepts from existing ones are the
// metaphors and the metonymies...
// Sometimes, however, the figure of speech is not obvious; the link between the new
// concept and the one to which it refers can be tenuous.
// As such, it is common to name a new application concept with regard to history and
// mythology. Indeed, our brains assimilate new concepts more easily when the references
// are simple and striking. But of course, if you want to striking, you have to be original.
// That is, the first person who came up with the idea of comparing a computer to a piece of
// fruit made a lasting impression; all subsequent attempts to make an impression by
// comparing computers to (other) pieces of fruit were completely in vain. 

// Writing code phase...
// It directly appears that an important aspect of code writing is about applying "good"
// naming conventions. 
// The never-ending debate about ‘good naming conventions’ in the realm of software is as
// old as the software industry itself...
// The difficulty of the exercise lies in the fact that programmers DO need to be rigorous
// in their naming conventions... But naming conventions that are too rigid or dogmatic 
// are also completely counterproductive...
// Let us consider two particular ‘extremes’:
// - minimalist naming conventions, based on simple, short names with no hierarchy, make
//   the code far too obscure and inevitably lead to endless naming conflicts;
// - the other extreme, based on very descriptive names (which are therefore very long) and
//   using systematic hierarchy, is no more manageable:
//   + long names composed of several words are NOT easily identified by humans and
//     unreasonably increase the weight of the code. 
//   + The excessive length of such code lines (200 characters or more) is also a concern, as
//     it makes routine operations—such as visual comparison (side by side) between
//     versions—very tedious.

// Therefore, legible code must be both concise and unambiguous (with names that ‘speak’ to
// us). How can we achieve two seemingly contradictory goals at the same time?
// Fortunately, figures of speech come to our rescue, allowing us to ‘reconcile the
// irreconcilable’...

// The basic rule is: when referring to (and therefore naming) an entity, avoid 
// circumlocutions and compound names. Use simple metaphors as much as possible.

// Another simple technique is to use metonymies and synecdoches.
// In fact, we often use metonymies unconsciously. In particular, when, in a (laudable)
// effort to be concise, we name the master module of our project after the project itself, we
// are using metonymy.
// However, it is important to bear in mind that this stylistic device can also create
// unfortunate confusion.
// Let me give you a simple example. A project I worked on for many years consisted of
// software AND specific hardware. The software part was (quite naturally) named after the
// project itself. Unfortunately, management quickly ended up confusing the software part of
// the project with the whole thing. The head of the software development team became the de
// facto manager of the entire project (including the hardware part) without this ever being
// clearly formalised. This explains (from my humble point of view) many of the erratic
// decisions that ensued...

-12345789-12345789-12345789-12345789-12345789-12345789-12345789-12345789-12345789-12345789
// Examples of useful figures of speech:
// - Personification: using a knowm character to name your application
// - Private joke: given the stato quo that we program in English, non English-native programmers use that opportunity to hide (dirty) slan words (in their mother tongue)  within obscure acronyms to
//   programmmers from the "rest of the world"....
