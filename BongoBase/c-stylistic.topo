// c-stylistic.topo
// (c) Puduku - 2025
// ================== DRAFT ==========================

// Using stylistic devices in C (and other programmming languages)
// Idea: In order to design applications and programme them properly, we also need to learn
// how to juggle with words and figures of speech... 
// In Programming/software development, one can (very roughly) distinct the two following phases:
// - preliminary conception/design 
// - developement: writing, compiling testing, debugging, fxing, improving, documenting,...
//
// During preliminary conception phase...
// A new design does not emerges from nothing. Rather, new programming concepts (modules,
// classes, processes and so on) are based on adaptation and extension (generalization or
// specification) of existing concepts (ideas, principles, theories) and artifacts
// (devices and natural phenomena).
// The major "engines" used by humans to derive new concepts from existing ones are the
// metaphors and the metonymies...
// In fact, to impress a new concept on the humain brain, it is not always necessary to resort
// to particularly relevant metaphors. It is enough for the references used to be simple and
// striking.
// As such, it is common to name a new application concept with regard to history and
// mythology. But of course, if you want to be really striking, you have to be original.
// That is, the first person who came up with the idea of comparing a computer to a piece of
// fruit made a lasting impression; all subsequent attempts to make an impression by
// comparing computers to (other) pieces of fruit were completely in vain... 

// Writing code phase...
// It directly appears that an important aspect of code writing is about applying "good"
// naming conventions. 
// The never-ending debate about ‘good naming conventions’ in the realm of software is as
// old as the software industry itself...
// The difficulty of the exercise lies in the fact that programmers DO need to be rigorous
// in their naming conventions... But naming conventions that are too rigid or dogmatic 
// are also completely counterproductive...
// Let us consider two particular ‘extremes’:
// - minimalist naming conventions, based on simple, short names with no hierarchy, make
//   the code far too obscure and inevitably lead to endless naming conflicts;
// - the other extreme, based on very descriptive names (which are therefore very long) and
//   using systematic hierarchy, is no more manageable:
//   + long names composed of several words are NOT easily identified by humans and
//     unreasonably increase the weight of the code. 
//   + The excessive length of such code lines (200 characters or more) is also a concern, as
//     it makes routine operations—such as visual comparison (side by side) between
//     versions—very tedious.

// Therefore, legible code must be both concise and unambiguous (with names that ‘speak’ to
// us). How can we achieve two seemingly contradictory goals at the same time?
// Fortunately, figures of speech come to our rescue...

// The basic rule is: when referring to (and therefore naming) an entity, avoid 
// circumlocutions and compound names. Use simple metaphors as much as possible.

// Another simple technique is to use metonymies and synecdoches.
// In fact, we often use metonymies unconsciously. In particular, when, in a (laudable)
// effort to be concise, we name the principal module of our project after the project
// itself, we are using metonymy.
// However, it is important to bear in mind that this stylistic device can also create
// unfortunate confusion.
// Let me give you a simple example. A project I worked on for many years consisted of
// software AND specific hardware. The software part was (quite naturally) named after the
// project itself. Unfortunately, management quickly ended up confusing the software part of
// the project with the whole thing. The head of the software development team became the de
// facto manager of the entire project (including the hardware part) without this ever being
// clearly formalised. This explains (from my humble point of view) many of the erratic
// decisions that ensued...

// Examples of useful figures of speech and other rhetorical technics:
// - Personification: using a knowm character to name your application
// - humoristic references
// -  ....



# Stylistic Devices in C and Other Programming Languages: Naming Conventions and Rhetoric
NOTICE: This note was completely rewritten with the assistance of AI
## Introduction

Writing quality software requires more than technical skill—it demands an 
understanding of language and rhetoric. Like literature, programming faces a 
fundamental challenge: balancing rigor with creativity. This note explores how 
figures of speech and rhetorical techniques can elevate code quality, 
particularly in naming conventions.

The central thesis is counterintuitive: both the absence of naming conventions 
and the imposition of overly rigid rules are equally harmful to code quality. 
The solution lies not in stricter rules, but in mastering stylistic devices 
drawn from rhetoric and literature.

---

## Part 1: Concept Formation and Design

### The Role of Metaphor in Conception

New programming concepts rarely emerge from nothing. Instead, they arise through 
**adaptation, generalization, or specialization** of existing concepts and 
phenomena. The primary mechanisms for deriving new concepts are **metaphor** and 
**metonymy**.

A well-chosen metaphor can imprint a concept on the human mind with remarkable 
efficiency. Striking simplicity matters more than perfect accuracy. The first 
person to compare computing to a tangible fruit (such as an apple) created a 
lasting impression. Subsequent attempts using similar analogies (such as an apricot),
however apt, fade into insignificance.

This principle applies directly to naming:
- **Original metaphors** create memorable, intuitive concepts
- **Derivative metaphors** confuse rather than clarify
- **Forced metaphors** burden rather than enlighten

### Naming from History and Mythology

A common and effective practice is to derive names from history and mythology. 
These familiar references ground abstract concepts in human experience. However, 
originality matters: the first innovative naming choice succeeds; copies do not.

---

## Part 2: Code and the Naming Crisis

### The Central Problem

An undeniable truth: naming conventions are fundamental to code quality. Yet 
the software industry has never resolved how to define "good" naming conventions. 
The difficulty is paradoxical:

1. Programmers **must** be rigorous and systematic in naming
2. Naming conventions that are **too rigid** become counterproductive

This tension mirrors the classic literary problem: how do you create meaningful 
expression within formal constraints?

### Two Extremes, Both Destructive

**Extreme 1: Minimalist Names**
- Simple, short names without hierarchy
- Consequence: Code becomes obscure and unmaintainable
- Problem: Inevitable naming conflicts across large codebases

**Extreme 2: Descriptive Names with Rigid Hierarchy**
- Long, compound names following systematic rules
- Consequences:
  - Humans poorly recognize long names (cognitive limitation)
  - Code weight increases unreasonably
  - Line lengths exceed 200 characters
  - Side-by-side comparison of code versions becomes tedious
  - Visual parsing requires excessive cognitive effort

Both extremes fail: one through obscurity, the other through verbosity.

### The Resolution: Concise and Unambiguous

The solution requires achieving two apparently contradictory goals simultaneously:
- **Conciseness**: Names must be brief
- **Clarity**: Names must be self-explanatory and unambiguous

This seeming paradox resolves through **rhetorical technique**—specifically, 
figures of speech.

---

## Part 3: Rhetorical Solutions

### The Fundamental Principle

**When naming an entity, avoid circumlocution and compound constructions. 
Employ simple, apt metaphors instead.**

This principle works because:
- A well-chosen metaphor communicates instantly
- Metaphorical names compress multiple concepts into single terms
- The brain processes metaphor more efficiently than literal description

### Metonymy and Synecdoche in Practice

Metonymy (substituting the name of one thing for another) is often used 
unconsciously in programming:

**Example: Project Names**
When a software project takes the name of the larger enterprise, this is 
metonymy—the part (software) represents the whole (project). While concise, 
this technique carries hidden risks.

**A Real Case Study:**

A multi-year project involved both custom software and specialized hardware. 
The software naturally adopted the project's name (metonymy). Over time, 
management conflated the software component with the entire project. The head 
of software development became, *de facto*, manager of the entire enterprise—
including hardware—without formal definition. This naming ambiguity contributed 
to organizational confusion and erratic decisions.

**Lesson:** Metonymy is powerful but dangerous. When using it, ensure context 
prevents misunderstanding. Explicit documentation may be necessary.

### Effective Figures of Speech

The following rhetorical devices serve naming well:

**Personification**
Name applications or modules after memorable characters (mythological, 
historical, literary). This creates instant recognition and semantic richness.
- Example: "Zeus" for a master controller (association with authority)
- Example: "Hermes" for message passing (association with communication)

**Humorous References**
A touch of humor makes names memorable without sacrificing clarity. However, 
ensure humor serves clarity—never obscures intent.

**Allusion**
Reference well-known concepts, tools, or phenomena from mathematics, physics, 
or culture. Educated readers immediately grasp the connection.
- Example: "entropy" for a randomization module
- Example: "quantum" for an indeterministic process

**Synecdoche**
Use a distinctive part to represent the whole, or vice versa.
- Example: "socket" instead of "network_socket_descriptor"

**Metaphor (Precise Use)**
Choose metaphors that genuinely illuminate the concept:
- "handle" ← grasping a resource (genuinely clarifies the abstraction)
- "queue" ← waiting in line (genuinely conveys FIFO semantics)
- "fork" ← splitting a path (genuinely conveys process creation)

---

## Part 4: Principles and Guidelines

### When Rhetoric Helps

Rhetorical devices excel when:
- A concept is complex or abstract
- Direct description would be verbose
- A vivid metaphor captures essential meaning
- Clarity and brevity must coexist

### When Rhetoric Harms

Avoid figures of speech when:
- The reference is obscure or context-dependent
- The metaphor misleads rather than illuminates
- Clarity requires explicitness (security, safety-critical code)
- Technical precision matters more than brevity

### The Balance

**Good naming achieves:**
- Sufficient specificity to prevent conflicts
- Sufficient generality to avoid verbosity
- Sufficient evocativeness to be memorable
- Sufficient clarity to be unambiguous

This balance is achieved through **selective, thoughtful use of rhetoric**—
not through rigid rules, and certainly not through avoidance of stylistic 
consideration.

---

## Conclusion

Programming is, fundamentally, an act of communication. Code communicates intent 
to machines *and* to humans. The humans reading code—whether reviewers, 
maintainers, or future versions of yourself—benefit from the same rhetorical 
craft that makes literature effective.

The false choice between "rigid rules" and "anything goes" is resolved by 
learning the craft of naming: understanding when to apply rules, when to break 
them, and how to use figures of speech to achieve clarity without compromise.

Invest in learning rhetoric. Your code will be better for it.






