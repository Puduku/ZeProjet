// karl.topo, version 1.92 (ANSI)
// (c) Atos-Euronext Belgium - 2008
// (c) Puduku - 2023

// KARL: Kit for Analysis and Rendering Layer
// "Extend" blotex to parse blottab2 - based on pamphlets (see c-ansi/engels.topo) 
//
// Using karl in blot code
// =========================
//
// structure : verset / alinea / paragraph / section / article / topic ( = spots)
// Blot pamplets operations
//
// See engels.topo for the description of pamphlets structure (spot / group / aggregate...) 
// NOTICE: contrary to blotregs and blottabs, there is NO "global" blottab2. Hence a blottab2 with
// empty entity name is simply a notation to refer the "current" blottab2 (cursor) 
//
// Specifiers:
// -----------
//
// <int blottab2 spec> ::= 'L' | 't' | 'z' | 'O' | 'i' | 'j' | 'p' | 'e' | 'l' | 'o' | 's' | 'I'
// <str blottab2 spec> ::= 'P' | 'T' | 'N' | 'd' | 'n' | 'r' | 'D' | 'v' | 'V' | 'w'
//
// Description of specifiers 
//   =r : raw reference
//   =D : pamphlet description
//   =L : pamphlet length
//   =N : pamphlet name
//   =d : spot description
//   =n : spot name
//   =t : spot type 
//   =z : spot depth in pamphlet
//   =T : spot expansion (tree representation) in pamphlet (with pamphlet spots iterator)
//   =P : spot path in pamphlet
//   =O : spot occurences specifier in pamphlet or aggregate 
//   =i : spot's occurence specifier in pamphlet or aggregate 
//   =j : spot's portion specifier 
//   =p : spot position in pamphlet (first char, taking into account the
//        portion specifier)
//   =e : spot's last char position in pamphlet (taking into account the
//        portion specifier) 
//   =l : spot length (taking into account the portion specifier) 
//   =o : spot offset position in pamphlet (first char, taking into account the
//        portion specifier) 
//   =s : spot's last char offset position in pamphlet (taking into account the
//        portion specifier) 
//   =v : spot's string content, narrowest representation, taking into account the intrinsic representation rules
//        +bytes string: trimmed to min length 
//         Note: in case you work on spot portion ({<portion>} specifier in spot reference), the 
//         narrowest representation does not applies; =v is equivalent to =V
//        +binary integer: as is (strict binary content); =v is equivalent to =V 
//   =V : spot's verbatim string content 
//        +bytes string: as is
//        +binary integer: as is (strict binary content) 
//   =w : spot's string content, widest representation, taking into account the intrinsic representation rules 
//        +bytes string: padded to max spot length 
//         Note: in case you work on spot portion ({<portion>} specifier in spot reference), the 
//         widest representation does not applies; =w is equivalent to =V
//        +binary integer: as is (strict binary content); =w is equivalent to =V 
//   =I : spot's logical integer value 


 
// Blot pamphlet ('r-value') spot references and operations:
// ---------------------------------------------------------
// NOTICE:  <int blottab2 ref> and <str blottab2 ref> 'l-value' spots and operations are NOT
// supported.
//
// REMINDER (see c-ansi/blotex.topo) :
// <int blottab2> ::= '^^' <entity> ( ( '?' <int blottab2 ops> ) | <int blottab2 spot> )
// <str blottab2> ::= '^^' <entity> ( ( '?' <str blottab2 ops> ) | <str blottab2 spot> )


// Spots:
// ------
//
// <blottab2 spot> ::= ( ( ( '.' <entity> [ '#' <intex> ] ) | ( '@' <intex> [ ':' <intex> ] ) )
//   [ '[' <intex> ']' ] [ <str portion> ] )+ 
// <int blottab2 spot> ::= [ <blottab2 spot> ] '=' <int blottab2 spec> 
// <str blottab2 spot> ::= [ <blottab2 spot> ] '=' <str blottab2 spec> 


// Operations:
// -----------
// <int blottab2 ops> ::= [ <blottab2 op select> ] [ <blottab2 op reset> ] [ <blottab2 op next> ]
//   [ <blottab2 op read int> ] 
// <blottab2 op select> ::= ':' <blottab2 request>
// <blottab2 op reset> ::= '^'
// <blottab2 op next> ::= '+'
// <blottab2 op read int> ::= '=' <int blottab2 spec> 
//
// <str blottab2 ops> ::= [ <blottab2 op select> ] [ <blottab2 op reset> ] [ <blottab2 op next> ]
//   [ <blottab2 op insert> ] <blottab2 op read str>
// <blottab2 op read str> ::= '=' <str blottab2 spec>
//
// Selections based on physical filel types ('#' => INT(LE/BE) '$' => chars)
// pamphlet physical spot type : byte sequence ($) or int (BE / LE) (#)
// TODO: logical selections (based on logical data type) ?)
// Like blotreg and blottabs requests, blottab2 requests are made of "atoms" : 
// <blottab2 request> ::= <blottab2 request atom> ( <logical 2op> <blottab2 request atom> )* ':?'
// <blottab2 request atom> ::= '*' | <blottab2 request atom int> | <blottab2 request atom str>
// <blottab2 request atom int> ::= '=' <int blottab2 spec> <comp op> <intex> )
// <blottab2 request atom str> ::= '=' <str blottab2 spec> <str comp op> <strex>

// TODO: date logical type (ag dedfinir dans blotex ?)

// EXAMPLES:
// ---------
// Operation examples : '^^' <entity> '?' ( <int blottab2 ops>  | <str blottab2 ops> )
// => dumping pamphlet RLCM1K:
//   ^^RLCM1K?: * :?  
// => dumping pamphlet RLCM1K, limited to spots having 2 depth max:
//   ^^RLCM1K?: =z <= 2 :?
// => dumping pamphlet RLCM1K, limited to spots containing "bolo":
//   ^^RLCM1K?: =V === "*bolo*" :? 
// => dumping pamphlet RLCM1K, limited to integer spots equal to 69:
//   ^^RLCM1K?: =I === 69 :? 
// => dumping pamphlet RLCM1K, limited to spots "CIdAdfEmetOm":
//   ^^RLCM1K?: =n == "CIdAdfEmetOm" :?
// => dumping pamphlet RLCM1K, limited to spots "CIdAdfEmetOm" with depth 2 max
//   ^^RLCM1K?: =n == "CIdAdfEmetOm" and =z <= 2 :?
// => Reset: 
//   ^^RLCM1K?^
// => Fetch next in RLCM1K: 
//   ^^RLCM1K?+
// => Fetch next in implicit pamphlet: 
//   ^^?+
// => Read current spot name in implicit pamphlet: 
//   ^^?=n 
//
// Spot examples : '^^' <entity> ( <int blottab2 spot> | <str blottab2 spot> )
// => Spots the total length of the 6 occurences of the AMeLim field: 
//   ^^RLC04K.AMeLim=l 
// => the value (string content) of the 1st occurence of AMeLim:
//   ^^RLC04K.AMeLim[1]=V
// => the complete RLC04K pamphlet string content:
//   ^^RLC04K=V
// => Spots the CIdAdfEmetOm field of the ACarOmDenAcKL aggregate:
//   ^^RLCM1K@232=V
// => Spots the ACarOmDenAcKL aggregate (depth == 1):
//   ^^RLCM1K@232:1=V 
// => Spots the CIdAdfEmetOm field of the ACarOmDenAcKL aggregate (depth == 2):
//   ^^RLCM1K@232:1=V
// => also the CIdAdfEmetOm spot of the ACarOmDenAcKL aggregate:
//   ^^RLCM1K.ACarOmDenAcKL.CIdAdfEmetOm=V
// => the ACarOmDenAcKL as aggregate: 
//   ^^RLCM1K.ACarOmDenAcKL=V
// => Spot portion example:
//   ^^RLC01K.DHTran{9-14}=V 
// => Spot portion example 2:
//   ^^RLC01K.DHTran{9:6}=V
// => Spots the 1st CIdAdfEmetOm field of RLCM1K (that comes from ACarOmDenAcKL aggregate) :
//   ^^RLCM1K.CIdAdfEmetOm#1=V
// => Also spots the 1st CIdAdfEmetOm field of RLCM1K: 
//   ^^RLCM1K.CIdAdfEmetOm=V 
