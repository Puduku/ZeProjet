// karl.topo, version 1.92 (ANSI)
// (c) Atos-Euronext Belgium - 2008
// (c) Puduku - 2023

// KARL: Kit for Analysis and Rendering Layer
// "Extend" blotex (blot hook) to parse blottab2 - based on pamphlets (see c-ansi/engels.topo) 
//
// Using karl in blot code
// =========================
//
// structure : verset / alinea / paragraph / section / article / topic
// Blot pamplets operations
//
// See engels.topo for the description of pamphlets structure (spot / group / aggregate...) 
// NOTICE: contrary to blotregs and blottabs, there is NO "global" blottab2. Hence a blottab2 with
// empty entity name is simply a notation to refer the "current" blottab2 (cursor) 
//
// Blot pamphlet spot  :
// <prot intex> ::= <int constant> | ( '(' <intex> ')' )  
// <blottab2 portion> ::= '{' <prot intex> [ ( ':' | '-' ) <prot intex> ] '}'  
// <blottab2 spot ref> ::= ( '.' <entity>  | '@' <prot intex> ']' [ '[' <prot intex> ']' ] [
//   <blottab2 portion> ] )* 
//
// <int blottab2 spot> ::= [ <blottab2 spot ref> ] '=' <int blottab2 spec> 
// <int blottab2 spec> ::= 'L' | 't' | 'z' | 'O' | 'i' | 'j' | 'p' | 'e' | 'l' | 'o' | 's'
//
// <str blottab2 spot> ::= [ <blottab2 spot ref> ] '=' <str blottab2 spec> 
// <str blottab2 spec> ::= 'P' | 'T' | 'N' | 'd' | 'n' | 'r' | 'D' | 'I' | 'v' | 'V' | 'w'
//
//
// NOTICE:  <int blottab2 ref> and  <str blottab2 ref> 'l-value' operations are NOT supported.
//
// Blot pamphlet ('r-value') spot references and operations :
// REMINDER (see c-ansi/blotex.topo) :
// <int blottab2> ::= '^^' <entity> ( ( '?' <int blottab2 ops> ) | <int blottab2 spot> )
// <str blottab2> ::= '^^' <entity> ( ( '?' <str blottab2 ops> ) | <str blottab2 spot> )
//
// <int blottab2 ops> ::= [ <blottab2 op select> ] [ <blottab2 op reset> ] [ <blottab2 op next> ]
//   [ <blottab2 op read int> ] 
// <blottab2 op select> ::= ':' <blottab2 request>
// <blottab2 op reset> ::= '^'
// <blottab2 op next> ::= '+'
// <blottab2 op read int> ::= '=' <<as value int>>
//
// <str blottab2 ops> ::= [ <blottab2 op select> ] [ <blottab2 op reset> ] [ <blottab2 op next> ]
//   [ <blottab2 op insert> ] <blottab2 op read str>
// <blottab2 op read str> ::= '=' <entity> <<as value str>> 
//
// Selections based on physical filel types ('#' => INT(LE/BE) '$' => chars)
// pamphlet physical spot type : byte sequence ($) or int (BE / LE) (#)
// TODO: logical selections (based on logical data type) ?)
// Like blotreg and blottabs requests, blottab2 requests are made of "atoms" : 
// <blottab2 request> ::= <blottab2 request atom> ( <logical 2op> <blottab2 request atom> )* ':?'
// <depth specifier> ::= '>' <prot intex>
// <blottab2 request atom> ::= '*' | <depth specifier> | <blottab2 request atom int> | <blottab2 request atom str>
// <blottab2 request atom int> ::= [ <<as value int>> ] <comp op> <prot intex> )
// <blottab2 request atom str> ::= ( <<as value str>> | <<as name>> ) <str comp op> <strex>

// TODO: date logical type (ag dedfinir dans blotex ?)

// EXAMPLES:
//   ^^RLCM1K?: * :?       => dumping pamphlet RLCM1K
//   ^^RLCM1K?: >2 :?    => dumping pamphlet RLCM1K, limited to pamphlet spots having 2 depth
//   ^^RLCM1K?: $ === "*bolo*" :?  => dumping pamphlet RLCM1K, limited to pamphlet spots containing "bolo"
//   ^^RLCM1K?: # === 69 :?        => dumping pamphlet RLCM1K, limited to integer pamphlet spots equal to 69 
//   ^^RLCM1K?: !$ == "CIdAdfEmetOm" :?  => dumping pamphlet RLCM1K, limited to spots "CIdAdfEmetOm"
//   ^^RLCM1K?: !$ == "CIdAdfEmetOm" and >2 :? 
//   ^^RLCM1K?^          => reset 
//   ^^RLCM1K?+          =>  fetch 
//   ^^?+                => fetch (implicit RLCM1K) 
//   ^^?=n               => read spot name (implicit RLCM1K) 
//   ^^RLC04K.AMeLim=l      => the length of 6 occurences of the AMeLim spot
//   ^^RLC04K.AMeLim[1]=V   => the value of the 1st occurence of AMeLim
//   ^^RLC04K=V        => the complete RLC04K pamphlet
//   ^^RLCM1K@232=V                        => the CIdAdfEmetOm spot of the ACarOmDenAcKL aggregate
//   ^^RLCM1K.ACarOmDenAcKL.CIdAdfEmetOm=V => also the CIdAdfEmetOm spot of the ACarOmDenAcKL aggreg
//   ^^RLCM1K.ACarOmDenAcKL=V              => the ACarOmDenAcKL as aggregate 
//   ^^RLC01K.DHTran{9-14}=V 
//   ^^RLC01K.DHTran{9:6}=V
////   ^^RLC04K?:.AMeLim[1] :?+=V   => the value of the 1st occurence of AMeLim 
////   ^^RLCM1K@232>1=V          => designates the ACarOmDenAcKL aggregate.
////   ^^RLCM1K@427&.CIdAdfEmetOm=V => (indicates both name and position of a spot)
////   ^^RLCM1K.CIdAdfEmetOm=V => also designates the CIdAdfEmetOm spot of the ACarOmDenAcKL aggreg

// Notice: blot pamphlet operations are NOT supported as 'l-value' operations.

// List of convertors utilizable in spot read op 
//   =r : raw reference
//   =D : pamphlet description
//   =L : pamphlet length
//   =N : pamphlet name
//   =d : spot description
//   =n : spot name
//   =t : spot type 
//   =z : spot depth in pamphlet
//   =T : spot expansion (tree representation) in pamphlet (with pamphlet spots iterator)
//   =P : spot path in pamphlet
//   =O : spot occurences specifier in pamphlet or aggregate 
//   =i : spot's occurence specifier in pamphlet or aggregate 
//   =j : spot's portion specifier 
//   =p : spot position in pamphlet (first char, taking into account the
//        portion specifier)
//   =e : spot's last char position in pamphlet (taking into account the
//        portion specifier) 
//   =l : spot length (taking into account the portion specifier) 
//   =o : spot offset position in pamphlet (first char, taking into account the
//        portion specifier) 
//   =s : spot's last char offset position in pamphlet (taking into account the
//        portion specifier) 
//   =v : spot's value, narrowest representation, taking into account the intrinsic representation rules
//        +bytes string: trimmed to min length 
//         Note: in case you work on spot portion ({<portion>} specifier in spot reference), the 
//         narrowest representation does not applies; =v is equivalent to =V
//        +binary integer: as is (strict binary content); =v is equivalent to =V 
//   =V : spot's verbatim value
//        +bytes string: as is
//        +binary integer: as is (strict binary content) 
//   =w : spot's value, widest representation, taking into account the intrinsic representation rules 
//        +bytes string: padded to max spot length 
//         Note: in case you work on spot portion ({<portion>} specifier in spot reference), the 
//         widest representation does not applies; =w is equivalent to =V
//        +binary integer: as is (strict binary content); =w is equivalent to =V 
//   =I : spot's raw binary value displayable image



