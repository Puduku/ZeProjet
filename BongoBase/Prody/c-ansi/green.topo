// green.topo, version 1.93 (ANSI)
// (c) Atos-Euronext Belgium - 2001, 2002, 2003


// PURPOSE: Simple patterns to facilitate sober (and hence "ecological") design...
// 
// GREEN INSTANCE / GREEN COLLECTION...
// ====================================
// 
// Principle : strict "data encapsulation" in "classes" - or similar object-oriented paradigm,
// is a safe (and popular) approach to represent and manage various data entities.   
// However, that approach is not very efficient when dealing with "collections" of such entities.
// The idea is to define a specific model of data entities - the "GREEN ITEM" - that easily aggregates  
// into collections... 

// 1. GREEN ITEM
// -------------
// A (compound) data type is "green" if:
// - The size of instances (in memory...) is:
//   + a "PUBLIC" datum, 
//   + NON NULL (> 0),
//   + CONSTANT,
//   + as SMALL as possible.
// - The instances are initialized by simple ZEROIZATION
// - During their lifespan, green instances hold two states:
//   - "disengaged" => (initial state after ZEROIZATION) "instanced" WITHOUT associated memory 
//     (or resource) to free
//   - "engaged" => specific disengaging actions required BEFORE destroying the instance 
// => a green instance is naturally referenced with an "handle" - we rather call a "stuff", that 
//    is a pointer to the instance's area in memory. 
// => Since we explicitly forbid the "0 instance size" corner case, a "green" stuff is necessarily
//    distinct of the technical "NULL pointer" - which is thus usable to represent (semantic) "special"
//    or "sentinel" values... 
// => ULTRA-green type: a green type that ALWAYS remains in "disengaged" state (i.e NO memory/resource
//    may be associated to ULTRA-green data) ; releasing ultra green types simply consists in freeing 
//    the instance's area in memory...
// => Utra but dirty green type: specific assignation of data fields necessary after zeroization... 
// 
// 
// 2. GREEN COLLECTION
// -------------------
// => GREEN COLLECTION == collection of VARIABLE number (>= 0) of green items. The "good" (and 
//    simple) properties of green items ease their management in "collections".  
// => ONE-by-ONE FETCH: efficiency of green collections management is enforced by the following
//    "principle" : green items generally only need to be fetched ONE by ONE in the collection.
// => PULL OUT: However, if needed, the items of a collection can be visible "globally" - simply
//    by temporarily giving access to the green items ARRAY. In such case, we simply stipulate
//    that the items are "pulled out" of the collection. 
// => FROZEN COLLECTION: we can also "freeze" the collection to prevent further modification. The
//    benefit of that operation is that the collection can be then safely shared by different
//    threads (of process)...  




// Example: fetching an item in that collection:
// +-- FIRST (i.e "lowest") item in collection with index
// |        +-- LAST (i.e "highest") item in collection with index
// v        v
// B; C; E; F
//
// => Simple fetch (No sequence); NOT valid for INDEX_FETCH__READ_NEXT
//      Key         : A  B  C  D  E  F  G
//      -----------------------------------
// I S| UP (*)      : B  B  B  B  B  B  B  |F I
// N E| DOWN (*)    : F  F  F  F  F  F  F  |E T
// D E| KEY         : -  B  C  -  E  F  -  |T E
// E K| BOTTOM_UP   : B  B  C  E  E  F  -  |C M
// X _| BOTTOM_DOWN : F  F  F  F  F  F  -  |H
// _ _| TOP_DOWN    : -  B  C  C  E  F  F  |E
//    | TOP_UP      : -  B  B  B  B  B  B  |D
// Legend: -: not found    (*): search key is not significant
//
// => Fetching in "read only" sequence;
//    INDEX_FETCH__READ_ONLY / READ_NEXT
//      #call (*)     :#1 #2 #3 #4 #5 #6
//      --------------------------------
// I S| UP            : B  C  E  F  -  - |F I
// N E| DOWN          : F  E  C  B  -  - |E T
// D E| KEY A         : -  -  -  -  -  - |T E
// E K| KEY B         : B  -  -  -  -  - |C M
// X _| KEY C         : C  -  -  -  -  - |H
// _ _| KEY D         : -  -  -  -  -  - |E
//    | KEY E         : E  -  -  -  -  - |D
//   (| KEY F         : F  -  -  -  -  - |
//   K| KEY G         : -  -  -  -  -  - |
//   e| BOTTOM_UP A   : B  C  E  F  -  - |
//   y| BOTTOM_UP B   : B  C  E  F  -  - |
//   )| BOTTOM_UP C   : C  E  F  -  -  - |
//    | BOTTOM_UP D   : E  F  -  -  -  - |
//    | BOTTOM_UP E   : E  F  -  -  -  - |
//    | BOTTOM_UP F   : F  -  -  -  -  - |
//    | BOTTOM_UP G   : -  -  -  -  -  - |
//    | BOTTOM_DOWN A : F  E  C  B  -  - |
//    | BOTTOM_DOWN B : F  E  C  B  -  - |
//    | BOTTOM_DOWN C : F  E  C  -  -  - |
//    | BOTTOM_DOWN D : F  E  -  -  -  - |
//    | BOTTOM_DOWN E : F  E  -  -  -  - |
//    | BOTTOM_DOWN F : F  -  -  -  -  - |
//    | BOTTOM_DOWN G : -  -  -  -  -  - |
//    | TOP_DOWN A    : -  -  -  -  -  - |
//    | TOP_DOWN B    : B  -  -  -  -  - |
//    | TOP_DOWN C    : C  B  -  -  -  - |
//    | TOP_DOWN D    : C  B  -  -  -  - |
//    | TOP_DOWN E    : E  C  B  -  -  - |
//    | TOP_DOWN F    : F  E  C  B  -  - |
//    | TOP_DOWN G    : F  E  C  B  -  - |
//    | TOP_UP A      : -  -  -  -  -  - |
//    | TOP_UP B      : B  -  -  -  -  - |
//    | TOP_UP C      : B  C  -  -  -  - |
//    | TOP_UP D      : B  C  -  -  -  - |
//    | TOP_UP E      : B  C  E  -  -  - |
//    | TOP_UP F      : B  C  E  F  -  - |
//    | TOP_UP G      : B  C  E  F  -  - |
// Legend: -: not found
//         (*): call #1           => READ_ONLY
//              calls #2, #3, ... => READ_NEXT
