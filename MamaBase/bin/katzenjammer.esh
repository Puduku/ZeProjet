# katzenjammer.esh : (bash) extension for katzenjammer (kids) scripts
   
# Uses "mama.esh" bash extension (formerly read and executed in the katzenjammmer (kids) script) 

# Notice: <EXT> and <PUB> info labels:
# - <PUB> label indicates "public" features (offered by script extensions). 
# - <EXT> label indicates "external" definitions (claimed by script extensions)
# => For completed info, type command: $ mama.sh -i  
  
. bye.esh
. adolf.esh

# (internal) working vars...
typeset -i _katzenjammer_i=-1
typeset -i _katzenjammer_ret=-1
typeset _katzenjammer_nam=

typeset -r _katzenjammer_scriptSuffix=.sh

_katzenjammer_nam=$(basename "$0")
if [ "${_katzenjammer_nam: -3}" != "$_katzenjammer_scriptSuffix" ] ;then
  ScriptFailure "Invalid script name '$_katzenjammer_nam' (missing or wrong suffix)"
fi
# <PUB> katzenjammer - Actual script name (eiher "fritz", "hans" or "der-inspector")
typeset -r katzenjammer=$(basename "$_katzenjammer_nam" "$_katzenjammer_scriptSuffix")
if [ "$katzenjammer" != hans -a "$katzenjammer" != fritz -a "$katzenjammer" != "der-inspector" ] ;then
  ScriptFailure "Invalid katzenjammer name : $katzenjammer"
fi

# <EXT> plot - describe (in one short line) the plot to be executed
typeset -r plot
if [ -z "$plot" ] ;then
  ScriptFailure "\"plot\" variable is NOT defined in script"
fi  

# <PUB> garden - The garden's RCA (real - canonicalized absolute) pathname. 
typeset -r garden=$(RCARealpath "$(dirname "$0")")

# (internal) 
_katzenjammer_Island () {
  local _i=0
  local _island="$1"
  while [ $_i -lt 25 -a "$_island" != "/" -a \
          ! \( -f "$_island/island" -o -f "$_island/ISLAND" -o -f "$_island/Island" -o \
               -f "$_island/.island" -o -f "$_island/.ISLAND" -o -f "$_island/.Island" \) ] ;do
    let "_i++"
    _island="$(dirname "$_island")"
  done
  echo -n "$_island"
}

# <PUB> island - The Island's RCA (real - canonicalized absolute) pathname 
export island="$(_katzenjammer_Island "$garden")"
#TODO: export really necessarry ? (when using $(Location XXX) )
typeset -r island

# <PUB> Garden - Any neighbor's garden RCA (real - canonicalized absolute) pathname.
# Passed:
#  -$1: rel garden pathname within island 
Garden () {
  RCARealpath "${island:?}/$1"
}

# <PUB> Location - this function builds "smart" location corresponding to given pathname. That is,
# the function issues "relative" path (vis-a-vis the object-working directory) when the 
# "move" happens within the "island". (otherwize, absolute path is chosen)
# In short, that function helps building more concise and readable commands.
# Passed:
#  -$1: pathname 
# TODO: voir ce qui se passe quand redpertoire courant (pwd) est en dehors de l'isle...
Location () {
  if [ -z "$island" ] ;then
    ScriptFailure "island var is not set!"
  fi
  if [ -n "$1" ] ;then
    Realpath "${island:?}" "$PWD" "$1"
  fi
}


# (internal use) : script taf id
# - 0 => script main function 
# - 1 => script creek function taf 1
# - 2 => script creek function taf 2
# - etc.
_katzenjammer_scriptTafId=0

# (internal use)
# - $1: (facet) com ret err out 
# - $2: command taf id 
#   + "" => generic (last command executed before abandonnement) 
#   + 0 => command executed
#   + 1 => command executed in taf 1
#   + 2 => command executed in taf 2
#   + etc.
_katzenjammer_CommandFacetFileName () {
  local _katzenjammerPostfix="[$_katzenjammer_scriptTafId]"
  local _commandPostfix=
  if [ -n "$2" ] ;then
    _commandPostfix="[$2]"
  elif [ "$_katzenjammer_scriptTafId" = 0 ] ;then
    _katzenjammerPostfix=
  fi
  echo -n ".${katzenjammer}${_katzenjammerPostfix}.command${_commandPostfix}.$1"
}  

# (internal use)
# - $1: (facet) com ret err out 
# - $2: command taf id 
_katzenjammer_CommandFacetFilePathname () {
  echo -n "$garden/$(_katzenjammer_CommandFacetFileName "$1" "$2")"
}

# (internal use)
# - $1: (facet) com ret err out 
# - $2: command taf id 
_katzenjammer_CommandFacetState () {
  local _f="$(_katzenjammer_CommandFacetFilePathname "$1" "$2")"
  if [ -s "$_f" ] ;then
    date -r "$_f" 
  else 
    echo "n/a"
  fi 
}



# (internal) 
typeset -r _katzenjammer_gardenLoquetFile=".katzenjammer.lock"

# (internal) 
typeset -r _katzenjammer_sourceCodeSection=1
typeset -r _katzenjammer_objectCodeSection=2
typeset -r _katzenjammer_testsOutputSection=3

# (internal)
# - "$1" : garden's pathname 
# - other arguments: loquet's options (see also enum of sections above)
# Exit status : loquet's exit status (0: OK ; >0:not possible) 
_katzenjammer_LockGarden () {
  if [ ! -d "${1}" ] ;then
    ScriptFailure "${1} is not a directory"
  fi
  if [ ! -w "${1}" ] ;then
    ScriptFailure "${1} directory is not accessible"
  fi
  local _loquetFilePathname="${1}/${_katzenjammer_gardenLoquetFile}"
  shift
  loquet "-N3" "$@" "$_loquetFilePathname"
  case $? in 
  [0123])
    return $?
    ;;
  *)
   ScriptFailure "[loquet $@ $_loquetFilePathname] command failed (ret=$?)"
  esac
}



_katzenjammer_displayMode=m
_katzenjammer_displayModeShowDepth=
_katzenjammer_executionMode=w

# <EXT> cleaning - indicates script cleaning actions  
# Possible options : 
# - x => cleaning not supported by script
# - s => supported but not asked
# - c => cleaning asked (then stop plot)
# - C => cleaning asked before executing actual plot
if [ -z "$cleaning" ] ;then
  cleaning=x
fi

# (internal use) _katzenjammer_creekFunctionCall - creek function to execute 
_katzenjammer_creekFunctionCall=

# (internal use) 
typeset -i _katzenjammer_depth=0

# (internal use)
# f : force lock (local)
# F : force lock (global)
# n : non blocking (abandon plot if garden is locked)
# d : default behaviour (wait for garden to be free)
_katzenjammer_forceExecution=d


# (internal) _katzenjammer_hotTarget - (variable) defines a specific target for plot execution.
# This optional argument is provided to katzenjammer script ; typically, it's a pathname constructed by 
# bash's completion.
# The variable is set as RCA (real - canonicalized absolute) pathname.
_katzenjammer_hotTarget=

# <EXT> ParseSpecificArgs - function 
# Passed 
# - "$@" : list of specific arguments to parse  


# <PUB> WrongSpecificArg - This function is useful when defining <EXT> ParseSpecificArgs
# function (See above).
# Simply call this function to report problem during parsing of
# "specific options" of katzenjammer (*) script.
# (*) katzenjammer kids
#
# Position arguments:
# $* : description of parsing problem
#ParseSpecificArgsFailure () {
WrongSpecificArg () {
  WrongScriptArg "Specific args: $*"
}

# (internal use) scriptArgsParsingStatus: specific statuses
# - 101: -h option passed 
# - 102: -i option passed
# - 103: -ih  options passed

# <EXT> specificUsage - variable
# Info lines describing the usage of specific arguments supported by katzenjammer script.
typeset -r specificUsage

_katzenjammer_tafPrefix=

while getopts :cCf:b:B:t:d:D:v:X:T:ih _o; do
  if [ $scriptArgsParsingStatus -eq 100 ] ;then
    break
  fi
  case $_o in 
  [bBcCdDfvXtT])
    if [ $scriptArgsParsingStatus -ge 100 ] ;then
      WrongScriptArg "Option -$_o conflicts with NON executive mode" 
    else 
      scriptArgsParsingStatus=0
      if [ $_o = d ] ;then
        if ! IsInteger "$OPTARG" ;then
          WrongScriptArg "Invalid -$_o $OPTARG opt arg" 
        else
          _katzenjammer_depth="$OPTARG"
        fi
      elif [ $_o = D ] ;then
        _katzenjammer_tafPrefix="$OPTARG"
      elif [ $_o = b ] ;then
        Hello "$OPTARG"
      elif [ $_o = B ] ;then
        _katzenjammer_creekFunctionCall="$OPTARG"
      elif [ $_o = t ] ;then
        _katzenjammer_scriptTafId="$OPTARG"
      elif [ "$_o" = c -o "$_o" = C ] ;then
        if [ "$cleaning" = x ] ;then
          WrongScriptArg "Cleaning option -$_o NOT supported in THIS script"
        else   
          cleaning=$_o
        fi
      elif [ $_o = f ] ;then
        case $OPTARG in
        [fFnd])
          _katzenjammer_forceExecution=$OPTARG
          ;;
        *)
          WrongScriptArg "Invalid -$_o $OPTARG opt arg" 
        esac
      elif [ $_o = v ] ;then
        case $OPTARG in
        [smvVt])
          _katzenjammer_displayMode=${OPTARG:0:1}
          _katzenjammer_displayModeShowDepth=
          ;;
        V+)
          _katzenjammer_displayMode=${OPTARG:0:1}
          _katzenjammer_displayModeShowDepth=+
          ;;
        *)
          WrongScriptArg "Invalid -$_o $OPTARG opt arg" 
        esac
      elif [ $_o = T ] ;then
        _katzenjammer_hotTarget=$(RCARealpath "$OPTARG")
      else # X
        case $OPTARG in
        [rwf])
          _katzenjammer_executionMode=$OPTARG
          ;;
        *)
          WrongScriptArg "Invalid -$_o $OPTARG opt arg" 
        esac
      fi
    fi
    ;;
  [hi])
    if [ $scriptArgsParsingStatus -eq 0 ] ;then
      WrongScriptArg "Option -$_o conflicts with executive mode" 
    elif [ $scriptArgsParsingStatus -ge 101 ] ;then
      scriptArgsParsingStatus=103
    elif [ $_o = i ] ;then
      scriptArgsParsingStatus=102
    else
      scriptArgsParsingStatus=101
    fi
    ;;
  \?)
    WrongScriptArg "Invalid option -$OPTARG" 
    ;;
  :) 
    WrongScriptArg "Option -$OPTARG requires an argument." 
    ;;
  *)
    ScriptFailure "Unexpected option [$_o] [$OPTARG]"
  esac 
done
if  [ $scriptArgsParsingStatus -eq -1 ] ;then
  scriptArgsParsingStatus=0
fi
typeset -r _katzenjammer_displayMode
typeset -r _katzenjammer_forceExecution
typeset -r _katzenjammer_hotTarget
typeset -r cleaning
if [ $scriptArgsParsingStatus -eq 0 ] ;then
  shift $(expr $OPTIND - 1)
  OPTIND=1
  if [ ! -z "$specificUsage" ] ;then
    ParseSpecificArgs "$@"
    _katzenjammer_ret=$?
    if [ $_katzenjammer_ret -eq 127 ] ;then 
      ScriptFailure "ParseSpecificArgs function is NOT defined" 
    fi
  elif [ $# -gt 0 ] ;then
    WrongScriptArg "Trailing arguments: $@"
  fi
fi
  

if [ "$katzenjammer" = "hans" ] ;then 
  #compiler profile
  _katzenjammer_gardenLock="-r$_katzenjammer_sourceCodeSection -w$_katzenjammer_objectCodeSection"
  _katzenjammer_gardenUnlock="-u$_katzenjammer_sourceCodeSection -u$_katzenjammer_objectCodeSection"
elif [ "$katzenjammer" = "fritz" ] ;then
  #tester profile
  _katzenjammer_gardenLock="-r$_katzenjammer_sourceCodeSection -r$_katzenjammer_objectCodeSection -w$_katzenjammer_testsOutputSection"
  _katzenjammer_gardenUnlock="-u$_katzenjammer_sourceCodeSection -u$_katzenjammer_objectCodeSection -u$_katzenjammer_testsOutputSection"
elif [ "$katzenjammer" = "der-inspector" ] ;then
  #documentalist profile
  _katzenjammer_gardenLock="-w$_katzenjammer_sourceCodeSection"
  _katzenjammer_gardenUnlock="-u$_katzenjammer_sourceCodeSection"
else
  _katzenjammer_gardenLock="-w0"
  _katzenjammer_gardenUnlock="-u0"
fi
typeset -r _katzenjammer_gardenLock
typeset -r _katzenjammer_gardenUnlock


if [ -z "$_katzenjammer_creekFunctionCall" ] ;then
  _katzenjammer_LockGarden "$garden" -C $_katzenjammer_gardenLock -t d -p $$
  _katzenjammer_ret=$?
  if [ $_katzenjammer_ret -ne 0 ] ;then 
    if [ $_katzenjammer_forceExecution = f -o $_katzenjammer_forceExecution = F ] ;then
      _katzenjammer_LockGarden "$garden" -c
    elif [ $_katzenjammer_forceExecution = n ] ;then
      WrongScriptArg "Garden is not accessible."
    elif [ $_katzenjammer_ret -ne 2 ] ;then
      WrongScriptArg "Garden's lock is broken ; you must force plot execution to recreate it."
    fi
  fi 
fi 

_katzenjammer_LoquetFileStatus () {
  _katzenjammer_LockGarden "$garden" -C $_katzenjammer_gardenLock -t d -p $$
  _katzenjammer_ret=$?
  if [ $_katzenjammer_ret = 2 ] ;then 
    echo "Garden is currently not accessible." 
  elif [ $_katzenjammer_ret = 0 ] ;then 
    echo "No lock on garden ; ready to execute plot." 
  else
    echo "Garden's lock is broken and must be recreated (some plot probably crashed)."
  fi
}

typeset -r _katzenjammer_commandSkinHead="$ANSI_WHITE"
typeset -r _katzenjammer_stderrSkinHead="$ANSI_RED"
typeset -r _katzenjammer_tafSkinHead="$ANSI_BLUE"
typeset -r _katzenjammer_skinButt="$ANSI_NC"

# (internal) TafTag 
_katzenjammer_TafTag () {
 if [ "$1" -gt 0 ] ;then
   local _head="<"
   local _butt=">"
   if [ "$2" = "b" ] ;then
     _butt=">>"
   elif [ "$2" = "e" ] ;then
     _head="<<"
   fi
   echo -ne " ${_katzenjammer_tafSkinHead}${_head}taf ${_katzenjammer_tafPrefix}$1${_butt}${_katzenjammer_skinButt}"
 fi
}


# (internal) _katzenjammer_KnownTargets - function 
# Passed: script taf id (typically: "$_katzenjammer_scriptTafId") 
# - 0 => script creek function main taf
# - 1 => script creek function taf 1
# - 2 => script creek function taf 2
# - etc.
_katzenjammer_KnownTargetsFile () {
  local _katzenjammerPostfix="[$1]"
  echo -n "${garden}/.${katzenjammer}${_katzenjammerPostfix}.targets"
}

# (internal) 
_katzenjammer_InfoDisplayKnownTargets () {
  local _i=0
  local _noTarget=$trueVal
  while [ $_i -le 3 ] ;do
    local _knownTargetsFile="$(_katzenjammer_KnownTargetsFile "$_i")"
    if [ -s "${_knownTargetsFile}" ] ;then
      _noTarget=$falseVal
      local _f 
      for _f in $(cat "${_knownTargetsFile}") ;do
        echo "==> $(Realpath "/" "$PWD" "$_f")" 
      done 
    fi
    let "_i++"
  done
  if [ "$_noTarget" = "$trueVal" ] ;then 
    echo "(no target)"
  fi
}

if [ $scriptArgsParsingStatus -ge 100 ] ;then
  cat >> /dev/stderr << KATZENJAMMER_PLAN
Plan: $plot
Garden: $garden/

KATZENJAMMER_PLAN

  if [ ! $scriptArgsParsingStatus -eq 102 ] ;then
    if [ $cleaning = x ] ;then
      _katzenjammer_cleaningSyn=
      _katzenjammer_cleaningDesc=
    else
      _katzenjammer_cleaningSyn="[ -c | -C ] " 
      _katzenjammer_cleaningDesc='
-c : Just clean garden... 
-C : Clean garden and then execute plot'
    fi
    cat >> /dev/stderr << KATZENJAMMER_HELP
Usage: $0 ${_katzenjammer_cleaningSyn}[ -f (f|F|n|d) ] [ -v (s|m|v|V|V+|t) ] [ -X (r|w|f) ] [ -T <hot target> ] [ -- <specific args> ] 
   or: $0 [ -h ] [ -i ] (NON-executive mode) 

In EXECUTIVE mode (default) :
-b <bye file> : (for recursive execution ; NOT USEFUL for manual execution...)
-B <creek function call> : (for recursive execution ; NOT USEFUL for manual execution...)
-t <taf id> : (for recursive execution ; NOT USEFUL for manual execution...)
-D <taf prefix> : (for recursive execution ; NOT USEFUL for manual execution...)
-d <depth> : >= 0 (for recursive execution ; NOT USEFUL for manual execution...) ${_katzenjammer_cleaningDesc}
-f f : force (local) => force local execution (remove garden's local trailing lock file if present)
   F : force (global) => force global execution (remove all gardens' trailing lock file if present)
   n : no blocking => abandon mission if garden is locked  
   d : default => wait wisely for the garden to be free...  
-v s : silent => nothing but serious notice is displayed
   m : minimal verbosity => only staging lines are displayed
   v : verbose => - full display of main stage ;
                  - represent staging lines of sub stages with dots
   V : very verbose => display all lines, in all stages
   V+: very verbose, show depth => display all lines, in all stages ; represent scripts calls' depth
   t : transparent display => display exactly as though all the commands were launched manually (in a sub-shell)
-X r : reckless execution ; ignore command failures...   
   w : wise execution ; abandon on explicit failures but pursue plot 
       after shady output (i.e stderr pollution without explicit failure report)  
   f : faint execution ; abandon plot upon any shady output 
-T <hot target> : specific target (if applicable) ; typically "bash-autocompleted" pathname  
Specific args:
${specificUsage:-(Not used)}

In NON executive mode: 
-h : help => displays that help
-i : info => reminds some technical informations 

KATZENJAMMER_HELP
  fi
  if [ $scriptArgsParsingStatus -eq 101 -o $scriptArgsParsingStatus -eq 103 ] ;then
    cat >> /dev/stderr << KATZENJAMMER_FULL_HELP
Exit status :
- 0 : "Object" plot fully executed
- 1 :  Plan could NOT complete (because of "object" command failure(s)) 
- 100 : Plan NOT executed (displayed some help in "stderr") 
- 200 : Catched technical problem in script (reported in "stderr")

KATZENJAMMER_FULL_HELP
  fi
  if [ $scriptArgsParsingStatus -eq 102 -o $scriptArgsParsingStatus -eq 103 ] ;then
    cat >> /dev/stderr << KATZENJAMMER_INFO1
Info files - $katzenjammer maintains the following (hidden) files in the garden:
These files retain status of last plain command executed but also of last commands executed in
parallel (i.e "in taf") 
Content:              ; Name:             ; Last: (last command CAUSING plot ABANDONMENT)
last command executed ; $(_katzenjammer_CommandFacetFileName com "") ; $(_katzenjammer_CommandFacetState com "")
last command output   ; $(_katzenjammer_CommandFacetFileName out "") ; $(_katzenjammer_CommandFacetState out "")
last command stderr   ; $(_katzenjammer_CommandFacetFileName err "") ; $(_katzenjammer_CommandFacetState err "")
last command status   ; $(_katzenjammer_CommandFacetFileName ret "") ; $(_katzenjammer_CommandFacetState ret "")
KATZENJAMMER_INFO1
_katzenjammer_i=0
while [ $_katzenjammer_i -le 3 ] ;do
  cat >> /dev/stderr << KATZENJAMMER_INFO2
Content:              ; Name:                   ; Last: $(_katzenjammer_TafTag $_katzenjammer_i) 
last command executed ; $(_katzenjammer_CommandFacetFileName com $_katzenjammer_i) ; $(_katzenjammer_CommandFacetState com $_katzenjammer_i)
last command output   ; $(_katzenjammer_CommandFacetFileName out $_katzenjammer_i) ; $(_katzenjammer_CommandFacetState out $_katzenjammer_i)
last command stderr   ; $(_katzenjammer_CommandFacetFileName err $_katzenjammer_i) ; $(_katzenjammer_CommandFacetState err $_katzenjammer_i)
last command status   ; $(_katzenjammer_CommandFacetFileName ret $_katzenjammer_i) ; $(_katzenjammer_CommandFacetState ret $_katzenjammer_i)
KATZENJAMMER_INFO2
  let "_katzenjammer_i++"
done
cat >> /dev/stderr << KATZENJAMMER_INFO3
Etc. ($katzenjammer accepts to execute up to 16 tafs in parallel...) 

Lock file - $katzenjammer maintains a lock file to prevent plot execution conflicts:
$(_katzenjammer_LoquetFileStatus)

Known targets - $katzenjammer remembers these specific targets:
$(_katzenjammer_InfoDisplayKnownTargets)
KATZENJAMMER_INFO3
  fi
  Bye 100 
fi


_katzenjammer_i=0
_katzenjammer_regularDepthArt=
_katzenjammer_1stDepthArt=
_katzenjammer_depthCommandPrompt='$'
while [ $_katzenjammer_i -lt $_katzenjammer_depth ] ;do
  _katzenjammer_regularDepthArt=${_katzenjammer_regularDepthArt}+
  _katzenjammer_depthCommandPrompt=${_katzenjammer_depthCommandPrompt}'$'
  let '_katzenjammer_i = _katzenjammer_i + 1'
done
if [ $_katzenjammer_depth -gt 1 ] ;then
  _katzenjammer_1stDepthArt=+
fi
typeset -r _katzenjammer_regularDepthArt
typeset -r _katzenjammer_1stDepthArt
typeset -r _katzenjammer_depthCommandPrompt


_katzenjammer_depthArt=
_katzenjammer_SetDepthArtCallsCount=0
_katzenjammer_SetDepthArt() {
  if [ "$_katzenjammer_displayModeShowDepth" = "+" ] ;then
    let "_katzenjammer_SetDepthArtCallsCount++"
    if [ $_katzenjammer_SetDepthArtCallsCount -gt 1 ] ;then
      _katzenjammer_depthArt="${_katzenjammer_regularDepthArt}"
    else 
      _katzenjammer_depthArt="${_katzenjammer_1stDepthArt}"
    fi 
  else
    _katzenjammer_depthArt=
  fi 
}

typeset -i _katzenjammer_foundTarget=$falseVal
if [ -z "${_katzenjammer_hotTarget}" ] ;then
  _katzenjammer_foundTarget=$trueVal
fi
 
# <PUB> IsTarget - indicates whether an artifact (defined in file system) is well a plot's target... 
# Passed:
#  -$1: artifact pathname 
# Ret:
# - 0 (true) : This artifact is well a target 
# - !=0 (false) : This artifact is not a target 
IsTarget () {
  local _rcaPathname=$(RCARealpath "$1")
  local _knownTargetsFile="$(_katzenjammer_KnownTargetsFile "$_katzenjammer_scriptTafId")"
  if ! grep -Fq "$_rcaPathname"  "$_knownTargetsFile" 2> /dev/null ;then
    echo "$_rcaPathname" >> "$_knownTargetsFile"
  fi
  if [ -z "${_katzenjammer_hotTarget}" ] ;then
    return $trueVal
  fi
  if [ "${_katzenjammer_hotTarget}" = "${_rcaPathname}" ] ;then
    _katzenjammer_foundTarget=$trueVal
    return $trueVal 
  fi
  return $falseVal
}

typeset -i _katzenjammer_pendingLine=$falseVal

_katzenjammer_NewLine () {
  if [ $_katzenjammer_pendingLine -eq $trueVal ] ;then 
    echo 
    _katzenjammer_pendingLine=$falseVal
  fi
  echo -e "$*"    
}

_katzenjammer_FeedLine () {
  echo -ne "$*"    
  _katzenjammer_pendingLine=$trueVal
}

_katzenjammer_NewFeedLine () {
 if [ $_katzenjammer_pendingLine -eq $trueVal ] ;then 
   echo 
 fi
 echo -ne "$*" 
 _katzenjammer_pendingLine=$trueVal
}

typeset -i _katzenjammer_displayDepth=0 

# <PUB> Info - display generic information (one textual line) in a katzenjammer script
# The actual displaying actually depends on:
# - the "display mode" specified to the script (transparent / verbose, etc.)
# - current "stage depth" 
#   the interpretation of "stage depth" is actually binary
#   + "stage depth" == 0 => "main stage" => display line in verbose modes
#   + "stage depth" > 0 => "sub stage" => display line only with heavy verbosity 
# (internal info)
# Different "modifiers" (special 1st argument) are supported
# - STEP: see Step public function 
# - STAGE: see Stage public function
# - BEWARE: see Beware public function
# - RAW: display raw line(s)  
# - RAW COMMAND: display raw command line(s) 
# - RAW STDERR: display raw (command) stderr line(s) 
Info () {
  local -i _displayModifier=0
  if [ "$1" = STEP ] ;then
    _displayModifier=1
    shift
  elif [ "$1" = STAGE ] ;then
    _displayModifier=2
    shift
  elif [ "$1" = BEWARE ] ;then
    if [ $_katzenjammer_displayMode != t ] ;then 
      shift
      _katzenjammer_SetDepthArt
      _katzenjammer_NewLine "${_katzenjammer_depthArt}$katzenjammer (!) $*"
    fi
    return
  elif [ "$1" = RAW ] ;then
    shift
    local _tPrefix=
    local _skinHead=
    local _skinButt=
    if [ "$1" = "COMMAND" ] ;then
      shift
      _tPrefix="${_katzenjammer_depthCommandPrompt} "
      if [ $_katzenjammer_displayMode != t ] ;then 
        _skinHead="$_katzenjammer_commandSkinHead"
        _skinButt="$_katzenjammer_skinButt"
      fi
    elif [ "$1" = "STDERR" ] ;then
      shift
      _skinHead="$_katzenjammer_stderrSkinHead"
      _skinButt="$_katzenjammer_skinButt"
    fi
    if [ $_katzenjammer_displayMode = V -o \( $_katzenjammer_displayDepth -eq 0 -a $_katzenjammer_displayMode = v  \) ] ;then 
      _katzenjammer_SetDepthArt
      _katzenjammer_NewLine "${_katzenjammer_depthArt}${_skinHead}$*${_skinButt}" 
    elif [ $_katzenjammer_displayMode = t ] ;then 
      _katzenjammer_NewLine "$_tPrefix${_skinHead}$*${_skinButt}" 
    fi 
    return
  fi    
  if [ $_katzenjammer_displayDepth -ge 1 ] ;then 
    if [ $_katzenjammer_displayMode = v  ] ;then 
      _katzenjammer_FeedLine "."
    elif [ $_katzenjammer_displayMode = V ] ;then 
      _katzenjammer_SetDepthArt
      _katzenjammer_NewLine "${_katzenjammer_depthArt}$katzenjammer ( ) $*" 
    fi
  else 
    if [ $_katzenjammer_displayMode = m ] ;then 
      if [ $_displayModifier -ge 1 ] ;then
        _katzenjammer_SetDepthArt
        _katzenjammer_NewLine "${_katzenjammer_depthArt}$katzenjammer (*) $*"
      fi
    elif [ $_katzenjammer_displayMode = v -o $_katzenjammer_displayMode = V ] ;then 
      if [ $_displayModifier -eq 0 ] ;then
        _katzenjammer_SetDepthArt
        _katzenjammer_NewLine "${_katzenjammer_depthArt}$katzenjammer ( ) $*"
      elif [ $_displayModifier -eq 1 ] ;then
        _katzenjammer_SetDepthArt
        _katzenjammer_NewLine "${_katzenjammer_depthArt}$katzenjammer (*) $*"
      else # STAGE 
        _katzenjammer_SetDepthArt
        _katzenjammer_NewFeedLine "${_katzenjammer_depthArt}$katzenjammer (*) $*"
      fi
    fi
  fi
}

# <PUB> Beware - display "important" line
# "Beware" lines have "highest" importance in plot report... 
# "Beware" lines are displayed with specific (!) marker 
Beware () {
  Info BEWARE "$*"
}

# <PUB> plotAbandoned - variable (true or false val) 
plotAbandoned=$falseVal

# <PUB> Abandon - indicates "katzenjammer" plot abandonment 
# To be called by katzenjammer script each time the plot is aborted
Abandon () {
#TODO :gedrer PROPREMENT _katzenjammer_pendingDecision ???
  Beware "Abandon plot"
  local _f 
  for _f in com ret err out ;do 
    if [ -f  "$(_katzenjammer_CommandFacetFilePathname "$_f" 0)" ] ;then 
      mv -f "$(_katzenjammer_CommandFacetFilePathname "$_f" 0)"  "$(_katzenjammer_CommandFacetFilePathname "$_f" "")"  
    fi
  done
  plotAbandoned=$trueVal
}

# <PUB> Step - display a "step" line.
# "Promotes" the importance of the line vis-a-vis single "Info" lines
# "Step" lines are displayed with specific (*) marker 
Step () {
  if [ $plotAbandoned != $trueVal ] ;then
    Info STEP "$*" 
  fi
}

# <PUB> Stage - display stage line. 
# "Stage" line has the same importance than a "step" line
# In addition, a "stage" line marks the creation of formal (sub-)stage
# (See also function EndStage)
Stage () {
  if [ $plotAbandoned != $trueVal ] ;then
    Info STAGE "$*"
  fi
  let '_katzenjammer_displayDepth = _katzenjammer_displayDepth + 1' 
}

# <PUB> EndStage - Indicates the end of a formal "stage" (see Stage function) 
EndStage () {
  if [ $_katzenjammer_displayDepth -ge 1 ] ;then
    let '_katzenjammer_displayDepth = _katzenjammer_displayDepth - 1'
  fi
}  

# (internal use) : these variables make sure that the script terminates cleanly...
typeset -i _katzenjammer_gardensVisitsCount=0
typeset -i _katzenjammer_tafs=$falseVal
typeset -i _katzenjammer_pendingDecision=$falseVal

# (internal use) 
_katzenjammer_End () {
  Info "Ended $(date)"
  if [ $_katzenjammer_pendingDecision -eq $trueVal -o \
       $_katzenjammer_gardensVisitsCount -gt 0 -o $_katzenjammer_tafs -eq $trueVal ] ;then
    ScriptFailure "Dirty state: #visits=$_katzenjammer_gardensVisitsCount tafs=$_katzenjammer_tafs pending=$_katzenjammer_pendingDecision" 
  fi
  if [ -z "$_katzenjammer_creekFunctionCall" ] ;then
    _katzenjammer_LockGarden "$garden" $_katzenjammer_gardenUnlock -p $$
  fi
  Bye $1 
}



# <PUB> Success - indicates "katzenjammer" plot success...
# To be called at the end of any katzenjammer script
Success () {
  local _ret=0
  if [ $plotAbandoned = $trueVal ] ;then
    _ret=1
  else 
    if [ -n "$_katzenjammer_creekFunctionCall" ] ;then
      Step "End of creek $_katzenjammer_creekFunctionCall"
    else
      if [ $_katzenjammer_foundTarget -ne $trueVal ] ;then
        Beware "Plan executed ; Hot target NOT FOUND"
        _ret=1
      else
        Step "Plan executed"
      fi
    fi
  fi 
  _katzenjammer_End $_ret 
}


# <PUB> CreekFunctions - Declare the creeks functions  
# Passed: list of ALL creek functions
CreekFunctions () {
  if [ -n "$_katzenjammer_creekFunctionCall" ] ;then
    local _ok=1 
    local _creekFunction=(${_katzenjammer_creekFunctionCall})
    for _fct in "$@" ;do
      if [ "$_fct" = "$_creekFunction" ] ;then
        _ok=0 
      fi
    done
    if [ "$_ok" != 0 ] ;then
      ScriptFailure "Unknown creek function [$_creekFunction]"
    fi
    Step "Follow creek $_katzenjammer_creekFunctionCall"
    $_katzenjammer_creekFunctionCall
    #$_creekFunction
    Success
  fi
}


# (internal) katzenjammer_commandRet - last command's exit status (aka "returned value")
typeset -i katzenjammer_commandRet=-1
# (internal) katzenjammer_commandOut - last command's output (in stdout) 
katzenjammer_commandOut=
# (internal) katzenjammer_commandErr - last command's complaint (in stderr) 
katzenjammer_commandErr=
# (internal) command - last command executed
katzenjammer_command=

typeset -i _katzenjammer_steered=$falseVal

_katzenjammer_SteeringFailure () {
  ScriptFailure "Bad command steering: $*"
}


# (Internal use)
# Passed :
# - $1: taf id (0 => general command ; > 0 => specific taf)
# - $katzenjammer_commandRet  
# - $katzenjammer_commandOut  
# - $katzenjammer_commandErr  
# - $_katzenjammer_steered
# - $_katzenjammer_executionMode
# Modified globals:
# - $_katzenjammer_pendingDecision
_katzenjammer_AnalyzeCommandExecution () {
  local _tafTag=$(_katzenjammer_TafTag $1 e)
  # display command out / err / ret:
  if [ -n "$katzenjammer_commandOut" ] ;then
    Info "Command output [*]$_tafTag"
    Info RAW "${katzenjammer_commandOut}$_tafTag"
  fi
  if [ ! $katzenjammer_commandRet -eq 0 ] ;then 
    Info "Command exited status $katzenjammer_commandRet$_tafTag"
  fi
  if [ -n "$katzenjammer_commandErr" ] ;then
    Beware "Command complained in stderr [$_katzenjammer_stderrSkinHead*$_katzenjammer_skinButt]$_tafTag" 
    Info RAW STDERR "$katzenjammer_commandErr" 
  fi
  # analyze command execution
  if [ $katzenjammer_commandRet -eq 127 ] ;then 
    Beware "Exit status $katzenjammer_commandRet possibly means command not found by shell$_tafTag"
  elif [ $katzenjammer_commandRet -eq 126 ] ;then 
    Beware "Exit status $katzenjammer_commandRet possibly means command is not executable$_tafTag"
  elif [ $katzenjammer_commandRet -eq 125 ] ;then 
    Beware "Exit status $katzenjammer_commandRet possibly means actual command status is undetermined$_tafTag"
  elif [ $katzenjammer_commandRet -gt 128 -a $katzenjammer_commandRet -lt 144 ] ;then 
    Beware "Exit status $katzenjammer_commandRet likely means command has been killed$_tafTag"
  fi
  if [ $_katzenjammer_steered -ne $trueVal ] ;then
    if [ $katzenjammer_commandRet -ne 0 ] ;then 
      if [ $_katzenjammer_executionMode != r ] ;then
        Beware "Command execution unsuccessful (status $katzenjammer_commandRet)$_tafTag"
        Abandon
      else
        Beware "Command execution unsuccessful (status $katzenjammer_commandRet) - BUT pursue plot...$_tafTag"
      fi
    elif [ -n "$katzenjammer_commandErr" ] ;then 
      Beware "Command execution reported as successful but polluted stderr$_tafTag"
      if [ $_katzenjammer_executionMode = f ] ;then
        Abandon
      fi
    fi
  else
    if [ $_katzenjammer_executionMode != r ] ;then
      _katzenjammer_pendingDecision=$trueVal
    fi
    if [ $katzenjammer_commandRet -ne 0 ] ;then 
      Beware "Steered command execution seems unsuccessful (status $katzenjammer_commandRet)$_tafTag"
    elif [ -n "$katzenjammer_commandErr" ] ;then 
      Beware "Steered command polluted stderr (status $katzenjammer_commandRet)$_tafTag"
    fi
  fi
}


typeset -i _katzenjammer_tafsNumber=0

_katzenjammer_TafsFailure () {
  ScriptFailure "Wrong tafs invocation: $*"
}


_katzenjammer_progressThreshold=150
if [ ${_katzenjammer_displayMode:?} = s ] ;then 
  _katzenjammer_progressThreshold=1
elif [ ${_katzenjammer_displayMode:?} = m ] ;then 
  _katzenjammer_progressThreshold=5
elif [ ${_katzenjammer_displayMode:?} = v ] ;then 
  _katzenjammer_progressThreshold=50
elif [ ${_katzenjammer_displayMode:?} = t ] ;then 
  _katzenjammer_progressThreshold=100
fi
typeset -r _katzenjammer_progressThreshold
 

# (internal) - indicates whether script hot target belongs to creek's targets 
# Passed : creek taf id (> 0) 
# Ret:
# - 0 (true) : script hot target belongs to creek's targets 
# - !=0 (false) : script hot target (if passed) is not a creek's target
_katzenjammer_SetCreekTarget () {
  eval $2=
  eval $3=
  if [ -z "$_katzenjammer_hotTarget" ] ;then
    return
  fi
  local _knownTargetsFile="$(_katzenjammer_KnownTargetsFile "$1")"
  if grep -Fq "$_katzenjammer_hotTarget"  "$_knownTargetsFile" 2> /dev/null ;then
    eval $2=-T
    eval $3=\"$_katzenjammer_hotTarget\"
  fi
}

# <PUB> EvalCommand - execute an (object-)command.
# What we call a command is running some executable - script, binary or bash built-in.
# TODO: c'est quoi une commande exactement => "echo AAAA > toto"  "echo XXXX &' => c'est bon?? (si oui
# il faudrait parentheser ???) 
# ACHTUNG (1): the passed command is evaluated (with 'eval' builtin command). Reasons:
# R1: make a clear distinction between subject (your script) and object (the command to execute) ;
# in particular avoid prematured interpretation (by subject script) of (object) command.  
# R2: Allow using the "Adolf" functions (see above)  
# ACHTUNG (2): invoked command may not be a local function defined in the script (or provided by
# katzenjammer environement !!!
# (this is not a technical limitation but a deliberate disposition ; the reason is to NOT confuse
# the "subject" - katzenjammer script - with its "object" - the commands executed)
# The "command" is supposed to behave as "commmonplace" UNIX commands (with their rudimentary
# execution status reporting...)
# Yet, in order to manage accurately the execution of the commands, the following assumptions have
# been established: 
# - about exit status : 
#   + 0: indicates more or less a "success" ; but we need to check whether command has not 
#     "complained" (in stderr) if we want a practical status...
#   + != 0 indicates something else (than a "success") : might be some "grave error"
#     or a "small warning", we don't know! "In general", however, the good old "binary logic" works
#     fine ; that is, "in general", != 0 means that the asked "service" of the command is simply
#     not "provided" (aka the binary counterpart of a "more or less success"...)
#     note: 127 is actually returned by the shell (rather than the command) to indicate that
#     the command is not found. But of course, if the command itself exits 127, you will have 
#     the same status, so that assertion is not 100% reliable...
#     (Otherwise, returned status -1 (255) is sometimes dedicated to indicate a technical problem -
#     whilst smallest values : 1, 2, etc are reserved to functional status. Though we are keen to 
#     qualify such dispositions as "good practices", we must however admit that, unfortunately, NO
#     clear conventions has emerged from that sane resolutions. Hence, and we simply deeply regret
#     that, we have not found an efficient way to deal with such "smart" commands...)
# - stderr analyzing: the fact that the command issued - or not - "something" in stderr
#   "empirically" provides indispensable information to consolidate the real status of the command:
#   + when there is nothing in stderr:
#     . with 0 status, conforts the "success" intrepretation...
#     . with != 0 status: tends to indicate that the nature of the error/warning is more
#       "functional" than "technical". 
#   + when there is something in stderr: 
#     . with 0 ("success") status, indicates some kind of "warning" but not necessarily
#       "technical". More precisely, the following (yet totally empiric) split generally "works".
#       Either means:
#       - functional warning
#       or
#       - simple technical pollution, with NO (or negligible) functional impact
#     . with != 0 status: tends to enforce the idea that the error is rather technical...  
#
# The behavior of EvalCommand function is altered by the following Katzenjammer script options:
# - execution mode 
#   + in r (reckless) mode: the function notifies any status that looks like "error" report, but
#     pursues plot as though nothing happened...
#   + in w (wise) mode: the function cares about "real" errors (and aborts plot), but tries to
#     continue the plot in case of "simple warnings"...
#   + in f (faint) mode: the function aborts the plot upon any "alert" (error or warning). 
# - display: the function adapts the output according to the specified display mode 
#
# Passed:
# $@ : the command to execute with its arguments
#
# (Internal doc)
# Passed: the following profiles are possible: 
# - YADUTAF CREEK <creek function name> [ <creek function 1st arg> ... ] : creek function execution 
# - YADUTAF KATZENJAMMER <katzenjammer script pathname>
# - YADUTAF <command 1st arg> ... : execute command "in parallel" 
# - STEERED <command 1st arg> ... : execute "steered" command
# - <command 1st arg> ... : execute ordinary command
#
# In globals:
# - $_katzenjammer_executionMode: 
# - $_katzenjammer_displayMode: 
# - $_katzenjammer_pendingDecision:
# Changed globals:
# - $katzenjammer_command: 
# - $_katzenjammer_steered
EvalCommand () {
  if [ $plotAbandoned = $trueVal ] ;then
    return
  fi
  if [ $_katzenjammer_pendingDecision -eq $trueVal ] ;then
    _katzenjammer_SteeringFailure "No decision taken after execution of command ($katzenjammer_command)" 
  fi
  _katzenjammer_steered=$falseVal
  local -i _yadutaf=$falseVal
  local -i _tafId=0
  local _retFile="$(_katzenjammer_CommandFacetFilePathname ret $_tafId)"
  katzenjammer_command="Undefined-Command"
  if [ "$1" = STEERED ] ;then
    _katzenjammer_steered=$trueVal
    shift 
    katzenjammer_command="$@"
  elif [ "$1" = YADUTAF ] ;then
    #TODO: check that the command is NOT a builtin... 
    _yadutaf=$trueVal
    shift 
    if [ $_katzenjammer_tafs -eq $trueVal -a $_katzenjammer_forceExecution != F ] ;then
      let "_tafId=++_katzenjammer_tafsNumber"
      _retFile="$(_katzenjammer_CommandFacetFilePathname ret $_tafId)"
    fi
    local _depth=$_katzenjammer_depth
    let "_depth++"
    local _tafPrefix="${_katzenjammer_tafPrefix}${_tafId}."
    if [ "$1" = CREEK ] ;then
      shift
      if [ $_tafId -ge 1 ] ;then
        local _creekFunctionCall="$@"
        local _TOpt=
        local _TArg=
        _katzenjammer_SetCreekTarget "$_tafId" _TOpt _TArg 
        katzenjammer_command="$(Adolf "$(Location "$garden/$katzenjammer$_katzenjammer_scriptSuffix")" "-b" "$(Location "$_retFile")" "-B" "$_creekFunctionCall" "-t" "$_tafId" -d "$_depth" -D "$_tafPrefix" "$_TOpt" "$_TArg" -v $_katzenjammer_displayMode$_katzenjammer_displayModeShowDepth)" 
      else
        eval "$@" 
        return
      fi
    elif [ "$1" = KATZENJAMMER ] ;then
      shift
      local _katzenjammerPathname="$1/$katzenjammer$_katzenjammer_scriptSuffix"
      case $cleaning in
      [cC])
        local _cOpt="-$cleaning"
        ;;
      *)
        local _cOpt=
      esac
      local _bOpt=
      local _bArg=
      local _fOpt=
      if [ $_tafId -ge 1 ] ;then
        _bOpt=-b
        _bArg="$(Location "$_retFile")" 
      elif [ $_katzenjammer_forceExecution = F ] ;then
        local _fOpt=-fF
      fi
      #TODO: on utlise Adolf juste pour edliminer les arguments vides ; est-ce une medthode clean ???? 
      katzenjammer_command=$(Adolf "$(Location "$_katzenjammerPathname")" $_bOpt "$_bArg" $_cOpt $_fOpt -d $_depth -D "$_tafPrefix" -v $_katzenjammer_displayMode$_katzenjammer_displayModeShowDepth) 
    else
      # TODO: la commande ne va pas gednedrer le ret file par magie ? Cca devrait cpt estre OK en mode "reckless execution"...
      katzenjammer_command="$@"
    fi
  else
    katzenjammer_command="$@"
  fi
  local _tafTag=$(_katzenjammer_TafTag $_tafId b)
  local _comFile="$(_katzenjammer_CommandFacetFilePathname com $_tafId)"
  local _outFile="$(_katzenjammer_CommandFacetFilePathname out $_tafId)"
  local _errFile="$(_katzenjammer_CommandFacetFilePathname err $_tafId)"
  echo "$katzenjammer_command" > "$_comFile"
  if [ $_katzenjammer_displayMode = t ] ;then 
    Info RAW COMMAND "${katzenjammer_command}$_tafTag"
  else
    local -i _n=$(echo "$katzenjammer_command" | wc -l)
    if [ $_n -eq 1 -a ${#command} -le 60 ] ;then
      Info "Execute command [$_katzenjammer_commandSkinHead$katzenjammer_command$_katzenjammer_skinButt]$_tafTag"
    else
      Info "Execute command [$_katzenjammer_commandSkinHead*$_katzenjammer_skinButt]$_tafTag"
      Info RAW COMMAND "$katzenjammer_command"
    fi
  fi
  local _progressMode=s
  if [ ${_katzenjammer_pendingLine:?} -eq ${trueVal:?} ] ;then 
    _progressMode=d
  fi
  if [ $_tafId -gt 0 ] ;then
    Welcome "$_retFile"
    # Magically, the command is supposed to handle $_retFile as bye file
    if [ -t 1 ] ;then 
      local -i _i
      let "_i=_tafId - 1"
      eval command "${katzenjammer_command[@]}" 2> "$_errFile" > >(tee "$_outFile" | progress -$_progressMode $_i $_katzenjammer_progressThreshold) &
    else
      eval command "${katzenjammer_command[@]}" 2> "$_errFile" > "$_outFile" &
    fi
  else
    if [ $_yadutaf -eq $trueVal -a -t 1 ] ;then 
      eval command "${katzenjammer_command[@]}" 2> "$_errFile" > >(tee "$_outFile" | progress -$_progressMode 0 $_katzenjammer_progressThreshold)
    else 
      eval command "${katzenjammer_command[@]}" 2> "$_errFile" > "$_outFile"
    fi
    katzenjammer_commandRet=$?
    echo $katzenjammer_commandRet > "$_retFile"
    katzenjammer_commandOut=$(cat "$_outFile")
    katzenjammer_commandErr=$(cat "$_errFile")
    _katzenjammer_AnalyzeCommandExecution $_tafId
  fi
}


# (Internal) _katzenjammer_TafsSession 
_katzenjammer_TafsSession () {
  if [ $_katzenjammer_tafs -eq $trueVal ] ;then
    _katzenjammer_TafsFailure "tafs session already started..."
  fi
  _katzenjammer_tafs=$trueVal
  _katzenjammer_tafsNumber=0
}

# <PUB> MainStage - display stage line and start a tafs session (allowing execution of tafs in parallel) 
# "Stage" line has the same importance than a "step" line
# In addition, a "stage" line marks the creation of formal (sub-)stage
# (See also function EndStage)
MainStage () {
  Stage "$*"
  _katzenjammer_TafsSession
}

# (Internal) _katzenjammer_EndTafsSession 
# (Internal notes:)
# Read globals: 
# -$_katzenjammer_tafs
# -$_katzenjammer_tafsNumber
# Modified globals:
_katzenjammer_EndTafsSession () {
  if [ $_katzenjammer_tafs -ne $trueVal ] ;then
    _katzenjammer_TafsFailure "no tafs session was started..."
  fi
  wait
  local -i _i=0
  local -i _tafId
  while [ $_i -lt $_katzenjammer_tafsNumber ] ;do
    let "_tafId = _i + 1"
    local _outFile="$(_katzenjammer_CommandFacetFilePathname out $_tafId)"
    local _errFile="$(_katzenjammer_CommandFacetFilePathname err $_tafId)"
    local _retFile="$(_katzenjammer_CommandFacetFilePathname ret $_tafId)"
    # $_retFile used to host "bye" file
    katzenjammer_commandRet=$(ByeStatus "$_retFile")
    # Synchronize $_retFile with final status (125 special case...)  
    echo $katzenjammer_commandRet > "$_retFile"
    katzenjammer_commandOut=$(cat "$_outFile")
    katzenjammer_commandErr=$(cat "$_errFile")
    _katzenjammer_AnalyzeCommandExecution $_tafId
    let "_i++"
  done
  _katzenjammer_tafs=$falseVal
}


# <PUB> EndMainStage - Indicates the end of a formal "stage" and tafs session (synchro point)
# see Stage function
EndMainStage () {
  _katzenjammer_EndTafsSession
  EndStage
}  

# <PUB> EvalSteeredCommand - execute a "steered" (object-)command.
# Use that function (instead of EvalCommand) when you want to execute an (object-)command which
# requires specific status interpretation... 
# At function return, you are REQUIRED to "decide" further actions depending on the status
# reported by the command. The following variables are at your disposal to analyze command status:
#  - $katzenjammer_commandRet: numeric status returned by command
#  - $katzenjammer_commandErr: stderr content (often, what's matter is "stderr content" or "NO stderr content" ?)   
#  - $katzenjammer_commandOut: stdout content (usefull in some cases of clumsy commands)
# Once you have "decided" you action, simply call SteeredCase function.
# And if you are in an unexpected situation (command returned unkwnown status, etc.) then call
# UnsteeredCase subject-function.
EvalSteeredCommand () {
  if [ $plotAbandoned = $trueVal ] ;then
    return
  fi
  EvalCommand STEERED "$@"
}
#TODO: Ca marche comme presvu ??? (gestion des blancs) => sinon SteeredCommand () (avec Adolf ???) 

# <PUB> SteeredCase - Handle steered case
# simply call that function ONCE you have decided what to do after return of a steered command.
# Note: Only call this function when there is really a "pending decision" (related to steered 
# command execution). It's a "programmatic error" to call that function WITHOUT "prending 
# decision"...
SteeredCase() {
  if [ $plotAbandoned = $trueVal ] ;then
    return
  fi
  if [ $_katzenjammer_pendingDecision -ne $trueVal -a $_katzenjammer_executionMode != r ] ;then
    _katzenjammer_SteeringFailure "NO pending decision regarding command status."
  fi
  _katzenjammer_pendingDecision=$falseVal
}

# <PUB> UnsteeredCase - Handle unsteered case
# Call that function if you can't interpret status of a "steered command", and you prefer to abandon the plot. 
# You can provide as argument any information related to that status that you are not able to
# understand... 
UnsteeredCase() {
  if [ $plotAbandoned = $trueVal ] ;then
    return
  fi
  SteeredCase
  Beware "Steered command exited unexpected status ($*)"
  Abandon
}

# (internal)  katzenjammer_IsWorkingDirectory -  
# Passed:
#  -$1: pathname 
katzenjammer_IsWorkingDirectory () {
  local _rcaPathname=$(RCARealpath "$1")
  if [ "$PWD" = "${_rcaPathname}" ] ;then
    return $trueVal 
  fi
  return $falseVal 
}

# <PUB> CommandCd - Change "object" and "subject" working directory 
# -$1: dir path
CommandCd () {
  if ! katzenjammer_IsWorkingDirectory "$1" ;then
    EvalCommand cd $(Adolf "$(Location "$1")")
  fi
}


# <PUB> CommandKatzenjammer - execute katzenjammer script (of another garden in the island)...
# This possibly durating command is executed with YADUTAF directive. That is, 
# the command will be executed in parallel with other tafs given a "tafs session" is open
# (See _katzenjammer_TafsSession function above) 
# 
# Passed:
# -"$1": katzenjammer garden pathname
CommandKatzenjammer () {
  if [ $# -gt 1 ] ;then 
    shift
    ScriptFailure "Unexpected args: $*"
  fi
  EvalCommand YADUTAF KATZENJAMMER "$1"
}


# <PUB> CommandCreek - execute creek function
# 
# Passed:
# -"$@": creek function call 
CommandCreek () {
  EvalCommand YADUTAF CREEK "$@"
}


typeset -a _katzenjammer_visitedGardens
typeset -a _katzenjammer_origins
typeset -a _katzenjammer_visitUnlocks

# <PUB> CommandVisitGarden - Enters neighbor's garden... 
# 
# Passed:
# -$1: katzenjammer script garden path
# -$2: visit "profile" :
#  + s => visit source code
#  + o => visit object code
#  + t => visit test output
#  + t => "full" visit
CommandVisitGarden () { 
#TODO: empiler mesme si la commande foire?????
  _katzenjammer_visitedGardens[$_katzenjammer_gardensVisitsCount]="$(RCARealpath "$1")"
  _katzenjammer_origins[$_katzenjammer_gardensVisitsCount]="$PWD"
  
  local _visitLock
  case $2 in 
  s) #source code
    _visitLock="-r$_katzenjammer_sourceCodeSection"
    _katzenjammer_visitUnlocks[$_katzenjammer_gardensVisitsCount]="-u$_katzenjammer_sourceCodeSection"
    ;;
  o) #object code
    _visitLock="-r$_katzenjammer_objectCodeSection"
    _katzenjammer_visitUnlocks[$_katzenjammer_gardensVisitsCount]="-u$_katzenjammer_objectCodeSection"
    ;;
  t) #tests output
    _visitLock="-r$_katzenjammer_testsOutputSection"
    _katzenjammer_visitUnlocks[$_katzenjammer_gardensVisitsCount]="-u$_katzenjammer_testsOutputSection"
    ;;
  f) #full visit
    _visitLock="-r0"
    _katzenjammer_visitUnlocks[$_katzenjammer_gardensVisitsCount]="-u0"
    ;;
  *)
   ScriptFailure "unexpected visit profile [$2]"
  esac
  let "_katzenjammer_gardensVisitsCount++"
  _katzenjammer_LockGarden "$1" -C $_visitLock
  CommandCd "$1"
}
   

# <PUB> CommandQuitGarden - Leaves neighbor's garden 
# 
# Passed:
# <None>
CommandQuitGarden () { 
  if [ $_katzenjammer_gardensVisitsCount -le 0 ] ;then
    ScriptFailure "No garden in visitation" 
  fi
  let "_katzenjammer_gardensVisitsCount--"
  local visitedGarden="${_katzenjammer_visitedGardens[$_katzenjammer_gardensVisitsCount]}"
  _katzenjammer_LockGarden "$visitedGarden" $_katzenjammer_visitUnlocks[$_katzenjammer_gardensVisitsCount]
  local origin="${_katzenjammer_origins[$_katzenjammer_gardensVisitsCount]}"
  CommandCd "$origin"
}
   

# Preparing plot execution... 
##########################

if [ -z "$_katzenjammer_creekFunctionCall" ] ;then
  _katzenjammer_LockGarden "$garden" $_katzenjammer_gardenLock -p $$

  if [ $cleaning = c ] ;then
    Step "Plan : $plot (Cleaning only)"
  else
    Step "Plan : $plot"
  fi

  Info "Garden : $garden/   (Island : ${island:-/}/)"
  
  _katzenjammer_DisplayModeInstructionsOutline () {
    echo -n "($_katzenjammer_displayMode) "
    case $_katzenjammer_displayMode in
    s)
      echo -n "silent" 
      ;;
    m)
      echo -n "moderate" 
      ;;
    v)
      echo -n "verbose" 
      ;;
    V) 
      echo -n "very verbose" 
      ;;
    t) 
      echo -n "transparent" 
      ;;
    *)
      echo -n "?" 
    esac
    echo " display mode"
  }
  
  _katzenjammer_ExecutionModeInstructionsOutline () {
    echo -n "($_katzenjammer_executionMode) "
    case $_katzenjammer_executionMode in 
    w)
      echo -n "wise (stops on errors)" 
      ;;
    f)
      echo -n "faint (stops on simple warnings)" 
      ;;
    r)
      echo -n "reckless (ignore errors)" 
      ;;
    *) 
      echo -n "?" 
    esac 
    echo " execution mode"
  }
  
  _katzenjammer_CleaningInstructionsOutline () {
    echo -n "($cleaning) "
    case $cleaning in 
    x)
      echo -n "(N/A)" 
      ;;
    s)
      echo -n "(no cleaning)" 
      ;;
    c)
      echo -n "pure cleaning (no other plot)" 
      ;;
    C)
      echo -n "do cleaning (before executing plot)" 
      ;;
    *) 
      echo -n "?" 
    esac 
  }
  
# <EXT> SpecificInstructionsOutline - function
# The function has to "echo" (in stdout) a short description (fitting in one line) of all specific
# options chosen to execute the plot... 
  
  Info "Generic instructions  : $(_katzenjammer_ExecutionModeInstructionsOutline) ; $(_katzenjammer_DisplayModeInstructionsOutline)"
  if [ "$cleaning" != x ] ;then
    Info "Cleaning instructions : $(_katzenjammer_CleaningInstructionsOutline)"
  fi
  if [ ! -z "$specificUsage" ] ;then
    _katzenjammer_specificInstructionsOutline="$(SpecificInstructionsOutline)"
    if [[ $? -eq 127 ]] ;then
      ScriptFailure "SpecificInstructionsOutline function is NOT defined" 
    fi
    Info "Specific instructions : $_katzenjammer_specificInstructionsOutline"
  fi
  
  if [ ! -z "$_katzenjammer_hotTarget" ] ;then
    Info "Hot target : $_katzenjammer_hotTarget"
  fi
  
  Info "Started $(date)"
  
  CommandCd "$garden" 
  
fi
